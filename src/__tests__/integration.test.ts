import { ItemController } from '../controllers/items.controller';
import itemService from '../services/item.service';
import mongoose from 'mongoose';

// Import the `ItemController`, the `itemService`, and `mongoose` to be used in the tests.
// The `ItemController` is what we are testing, `itemService` is the service layer we will mock, and `mongoose` helps generate object IDs.

// Mock the itemService methods
jest.mock('../services/item.service');
// Jest is used to mock the `itemService` functions to control their behavior during testing.
// This means we can simulate the responses of these functions without interacting with a real database or service.

describe('ItemController Unit Tests', () => {
  let controller: ItemController;

  // Before each test, initialize a new instance of the `ItemController`.
  beforeEach(() => {
    controller = new ItemController();
  });

  // A mock response object that represents an item (with an autogenerated mongoose ObjectId).
  const mockItemResponse = {
    _id: new mongoose.Types.ObjectId(),
    name: 'Test Item',
    category: 'Test Category',
    price: 100
  };

  // A valid item request that represents data needed to create an item.
  const validItemRequest = {
    name: 'Test Item',
    category: 'Test Category',
    price: 100
  };

  // Test the `createItem` method of the `ItemController`.
  it('should create an item successfully', async () => {
    // Mock the `itemService.createItems` method to resolve with the validItemRequest data.
    (itemService.createItems as jest.Mock).mockResolvedValue(validItemRequest);

    // Call the `createItem` method of the `ItemController` with valid request data.
    const response = await controller.createItem(validItemRequest);

    // Expect the response to match a successful item creation message and the expected item data.
    expect(response).toEqual({
      message: 'Successfully',
      data: {
        _id: expect.any(mongoose.Types.ObjectId),  // We use `expect.any` because the ObjectId is generated dynamically.
        name: 'Test Item',
        category: 'Test Category',
        price: 100
      }
    });

    // Ensure the `itemService.createItems` method was called with the valid request data.
    expect(itemService.createItems).toHaveBeenCalledWith(validItemRequest);
  });

  // Test the `getItemById` method of the `ItemController`.
  it('should return an item by id', async () => {
    // Mock the `itemService.getItemById` method to resolve with the mock item response.
    (itemService.getItemById as jest.Mock).mockResolvedValue(mockItemResponse);

    // Call the `getItemById` method of the `ItemController` with the item's ID.
    const response = await controller.getItemById(mockItemResponse._id.toString());

    // Expect the response to match a successful retrieval message and the expected item data.
    expect(response).toEqual({
      message: 'success',
      data: mockItemResponse
    });

    // Ensure the `itemService.getItemById` method was called with the correct ID.
    expect(itemService.getItemById).toHaveBeenCalledWith(mockItemResponse._id.toString());
  });

  // Test the `updateItemById` method of the `ItemController`.
  it('should update an item by id', async () => {
    const updatedItemRequest = {
      name: 'Updated Item',
      category: 'Updated Category',
      price: 150
    };

    const updatedMockItemResponse = {
      ...mockItemResponse,  // Spread the original mockItemResponse and overwrite with updated fields.
      ...updatedItemRequest
    };

    // Mock the `itemService.updateItemById` method to resolve with the updated item data.
    (itemService.updateItemById as jest.Mock).mockResolvedValue(updatedMockItemResponse);

    // Call the `updateItemById` method of the `ItemController` with the item's ID and updated request data.
    const response = await controller.updateItemById(mockItemResponse._id.toString(), updatedItemRequest);

    // Expect the response to match a successful update message and the updated item data.
    expect(response).toEqual({
      message: 'success',
      data: updatedMockItemResponse
    });

    // Ensure the `itemService.updateItemById` method was called with the correct ID and updated request data.
    expect(itemService.updateItemById).toHaveBeenCalledWith(mockItemResponse._id.toString(), updatedItemRequest);
  });

  // Test the `deleteItemById` method of the `ItemController`.
  it('should delete an item by id', async () => {
    // Mock the `itemService.deleteItemById` method to resolve with null (as no data is returned for deletion).
    (itemService.deleteItemById as jest.Mock).mockResolvedValue(null);

    // Call the `deleteItemById` method of the `ItemController` with the item's ID.
    await controller.deleteItemById(mockItemResponse._id.toString());

    // Ensure the `itemService.deleteItemById` method was called with the correct ID.
    expect(itemService.deleteItemById).toHaveBeenCalledWith(mockItemResponse._id.toString());
  });

  // Test the `getAllItems` method of the `ItemController`.
  it('should return a list of items', async () => {
    const mockItemsResponse = {
      total: 1,
      items: [mockItemResponse]
    };

    // Mock the `itemService.getAllItems` method to resolve with the list of items.
    (itemService.getAllItems as jest.Mock).mockResolvedValue(mockItemsResponse);

    // Call the `getAllItems` method of the `ItemController` with query parameters.
    const response = await controller.getAllItems({ limit: 10, page: 1 });

    // Expect the response to match a successful retrieval message and the list of items.
    expect(response).toEqual({
      message: 'success',
      data: mockItemsResponse
    });

    // Ensure the `itemService.getAllItems` method was called with the correct query parameters.
    expect(itemService.getAllItems).toHaveBeenCalledWith({ limit: 10, page: 1 });
  });
});
